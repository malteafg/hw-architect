// avoid updating all id references when element is removed

// no references to other nodes or segments in either of them
struct Node {}
// need to be different for transition segments
struct Segment {}

type NodeId = u16;
type SegmentId = u16;

// consider using hash maps instead
let node_map = BTreeMap<NodeId, Node>;
let segment_map = BTreeMap<SegmentId, Segment>;

// consider storing the reverse graph as well, probably a good idea for use with direction of road tool
let node_refs = BTreeMap<NodeId, (Vec<NodeId>, Vec<SegmentId>)>;
let backward_graph;
// let segment_refs = BTreeMap<NodeId, Vec<SegmentId>>;

// perhaps squish when saving or something like that
let available_node_ids: Vec<NodeId>;
let available_segment_ids: Vec<SegmentId>;

fn add_node(nodes_to_connect_to) {
  let node_id = available_node_id otherwise node_map.len()
  update node_refs with nodes_to_connect_to
  insert node_map
}

fn add_segment(nodes_to_connect_to, direction) {
  let segment_id = available_segment_id or segment_map.len()
  update node_refs with nodes_to_connect_to
  insert segment_map
}

fn remove_node(NodeId) {
  remove entry in maps with nodeid
  loop through node_refs and remove nodeid
}

fn remove_segment(NodeId) {
  remove entry in maps with segmentid
  loop through node_refs and remove segmentid
}

// bunch more helper functions to get nodes and stuff like that

// HOW TO EXPOSE RELEVANT DATA (mesh, path finding, and stuff for ray tracing)
// Path finding should be easily derivable from node_refs, probably just compute a new map where segment is just its length and speed

// Ray tracing (Clickable trait in Input?)
// If input gets this far (has not been taken by UI), first check if within radius of node, then check segment what about clicking cars?
// Nodes just return a position and radius (perhaps height for cylinder)
// Segment?

// RoadMesh (Mesh trait in Graphics?) (also lane markings, don't care about efficiency it just needs to be done)
// 
